<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Note Secretary – DroidScript Backend</title>
<style>
  body { margin:0; font-family: system-ui, Arial, sans-serif; background:#0b0d10; color:#e6e6e6; }
  .app { display:flex; flex-direction:column; height:100dvh; max-width:820px; margin:0 auto; }
  header { padding:12px 16px; border-bottom:1px solid #222; display:flex; gap:8px; align-items:center; }
  header h1 { font-size:16px; margin:0; font-weight:600; }
  header .spacer { flex:1; }
  select, button, input[type="text"] { background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:6px 10px; }
  #log { flex:1; overflow:auto; padding:16px; display:flex; flex-direction:column; gap:10px; }
  .msg { max-width:85%; padding:10px 12px; border-radius:14px; line-height:1.35; white-space:pre-wrap; display:flex; flex-direction:column; gap:4px; }
  .you { align-self:flex-end; background:#1f6feb; color:white; border-bottom-right-radius:4px; }
  .bot { align-self:flex-start; background:#15181c; border:1px solid #2a2f36; border-bottom-left-radius:4px; }
  .sys { align-self:center; font-size:12px; opacity:.8; }
  .msg-content { flex:1; }
  .msg-timestamp { font-size:10px; opacity:0.7; text-align:right; margin-top:2px; }
  .you .msg-timestamp { color:rgba(255,255,255,0.8); }
  .bot .msg-timestamp { color:#a0a0a0; }
  .sys .msg-timestamp { color:#a0a0a0; text-align:center; }
  form { display:flex; gap:8px; padding:12px 16px; border-top:1px solid #222; }
  textarea { flex:1; resize:none; height:70px; background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:10px; }
  button.primary { background:#1f6feb; color:white; border:none; border-radius:12px; padding:10px 14px; }
  #micBtn { background:#15181c; color:#e6e6e6; border:1px solid #2a2f36; border-radius:12px; padding:10px 14px; cursor:pointer; font-size:16px; transition: all 0.3s ease; }
  #micBtn.recording { background:#ff4444 !important; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.5; } 100% { opacity: 1; } }
  .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; padding:8px 16px; }
  .warn { font-size:12px; opacity:.75; padding:0 16px; }
  
  /* Side Menu Styles */
  .side-menu { position:fixed; top:0; left:-300px; width:300px; height:100vh; background:#1a1d21; border-right:1px solid #333; z-index:1000; transition:left 0.3s ease; }
  .side-menu.open { left:0; }
  .side-menu-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .side-menu-content { padding:16px; }
  .side-menu h2 { margin:0 0 16px 0; font-size:18px; color:#e6e6e6; }
  .side-menu label { display:block; margin-bottom:8px; color:#e6e6e6; font-size:14px; }
  .side-menu input[type="text"], .side-menu input[type="password"] { width:100%; padding:8px; background:#2a2f36; color:#e6e6e6; border:1px solid #444; border-radius:6px; margin-bottom:16px; }
  .side-menu button { background:#1f6feb; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; margin-right:8px; }
  .side-menu button.secondary { background:#444; }
  .side-menu button.nav-button { width:100%; margin:0 0 8px 0; font-size:16px; padding:12px 16px; }
  .side-menu button.nav-button:disabled { opacity:0.5; cursor:not-allowed; }
  .side-menu button.nav-button.active { background:#2d5a87; border:2px solid #1f6feb; }
  .overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999; display:none; }
  .overlay.show { display:block; }
  
  /* Commands Popup Styles */
  .commands-popup { position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); width:400px; max-height:80vh; background:#1a1d21; border:1px solid #333; border-radius:12px; z-index:1001; display:none; overflow:hidden; }
  
  /* Upload Modal Styles */
  .upload-modal { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1002; display:none; }
  .upload-modal.show { display:flex; align-items:center; justify-content:center; }
  .upload-content { background:#1a1d21; border:1px solid #333; border-radius:12px; width:90%; max-width:500px; max-height:80vh; overflow:hidden; }
  .upload-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .upload-header h3 { margin:0; color:#e6e6e6; }
  .upload-close { background:none; border:none; color:#a0a0a0; font-size:20px; cursor:pointer; }
  .upload-body { padding:20px; }
  .upload-area { border:2px dashed #444; border-radius:8px; padding:40px 20px; text-align:center; margin-bottom:20px; cursor:pointer; transition:border-color 0.3s; }
  .upload-area:hover { border-color:#1f6feb; }
  .upload-area.dragover { border-color:#1f6feb; background:#0f1419; }
  .upload-icon { font-size:48px; margin-bottom:16px; }
  .upload-text { color:#a0a0a0; margin-bottom:8px; }
  .upload-hint { font-size:12px; color:#666; }
  .file-input { display:none; }
  .preview-container { display:flex; flex-wrap:wrap; gap:10px; margin-bottom:20px; }
  .preview-item { position:relative; width:80px; height:80px; border-radius:8px; overflow:hidden; }
  .preview-item img { width:100%; height:100%; object-fit:cover; }
  .preview-remove { position:absolute; top:4px; right:4px; background:#ff4444; color:white; border:none; border-radius:50%; width:20px; height:20px; font-size:12px; cursor:pointer; }
  .upload-buttons { display:flex; gap:10px; justify-content:flex-end; }
  .upload-btn { background:#1f6feb; color:white; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; }
  .upload-btn:disabled { background:#444; cursor:not-allowed; }
  .cancel-btn { background:#444; color:#e6e6e6; border:none; padding:10px 20px; border-radius:8px; cursor:pointer; }
  .commands-popup.show { display:block; }
  .commands-header { padding:16px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center; }
  .commands-header h3 { margin:0; font-size:18px; color:#e6e6e6; }
  .commands-header button { background:none; border:none; color:#e6e6e6; font-size:20px; cursor:pointer; }
  .commands-content { padding:16px; max-height:60vh; overflow-y:auto; }
  .command-category { margin-bottom:20px; }
  .command-category h4 { margin:0 0 12px 0; font-size:14px; color:#e6e6e6; font-weight:600; }
  .command-btn { display:block; width:100%; padding:8px 12px; margin-bottom:6px; background:#2a2f36; color:#e6e6e6; border:1px solid #444; border-radius:6px; cursor:pointer; font-size:14px; text-align:left; transition:all 0.2s ease; }
  .command-btn:hover { background:#1f6feb; border-color:#1f6feb; }
</style>
</head>
<body>
<div class="app">
  <header>
    <button id="menuBtn" title="Settings">☰</button>
    <h1>Note Secretary</h1>
    <div class="spacer"></div>
    <label for="lang">Lang:</label>
    <select id="lang">
      <option value="en" selected>EN</option>
      <option value="he">HE</option>
    </select>
    <button id="clear">Clear</button>
  </header>

  <p class="warn" id="tipSection">Tip: Try compact commands like <code>/createnote groceries</code> or <code>/findnote groceries</code>. For editing: <code>/findnote groceries</code> then <code>/editdescription</code>. To see all notes: <code>/showparents</code>. Speech works via the browser's Web Speech API. Gemini here is for **testing only**—your key is exposed.</p>

  <div id="log"></div>

  <form id="chat">
    <textarea id="input" placeholder="Type a message…"></textarea>
    <button class="primary" type="submit">Send</button>
  </form>
  
  <div class="row" style="padding: 8px 16px; border-top: 1px solid #222;">
    <label><input type="checkbox" id="useTTS"> 🔊 Read responses</label>
    <button id="micBtn" title="Speech to text">🎤 Speak</button>
    <button id="helpBtn" title="Quick commands">💡 Commands</button>
  </div>
</div>

<!-- Upload Modal -->
<div id="uploadModal" class="upload-modal">
  <div class="upload-content">
    <div class="upload-header">
      <h3>Upload Images</h3>
      <button class="upload-close" onclick="closeUploadModal()">&times;</button>
    </div>
            <div class="upload-body">
              <div class="upload-area" onclick="selectImages()">
                <div class="upload-icon">📷</div>
                <div class="upload-text">Click to select images</div>
                <div class="upload-hint">Supports JPG, PNG, GIF (max 5 images)</div>
              </div>
              
              <!-- Alternative file selection for WebView environments -->
              <div id="webviewAlternatives" style="display: none; margin-top: 10px; text-align: center;">
                <p style="color: #666; font-size: 14px; margin: 10px 0;">File picker not working? Try these alternatives:</p>
                <button onclick="createMockFileSelection()" style="margin: 5px; padding: 8px 16px; background: #ff6b35; color: white; border: none; border-radius: 4px; cursor: pointer;">
                  🧪 Use Mock File (Testing)
                </button>
                <button onclick="showManualFileInput()" style="margin: 5px; padding: 8px 16px; background: #1f6feb; color: white; border: none; border-radius: 4px; cursor: pointer;">
                  📂 Try Alternative Picker
                </button>
              </div>
              
      <input type="file" id="fileInput" class="file-input" multiple accept="image/*" style="display: none;">
      <div id="previewContainer" class="preview-container"></div>
              <div class="upload-buttons">
                <button class="cancel-btn" onclick="closeUploadModal()">Cancel</button>
                <button class="upload-btn" id="uploadBtn" onclick="uploadImages()" disabled>Upload</button>
              </div>
    </div>
  </div>
</div>

<!-- Commands Popup -->
<div class="overlay" id="commandsOverlay"></div>
<div class="commands-popup" id="commandsPopup">
  <div class="commands-header">
    <h3>Quick Commands</h3>
    <button id="closeCommands">✕</button>
  </div>
  <div class="commands-content" id="commandsContent">
    <!-- Commands will be populated dynamically based on current mode -->
  </div>
</div>

<!-- Side Menu -->
<div class="overlay" id="overlay"></div>
<div class="side-menu" id="sideMenu">
  <div class="side-menu-header">
    <h2>Settings</h2>
    <button id="closeMenu">✕</button>
  </div>
  <div class="side-menu-content">
    <h3>Navigation</h3>
    <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:20px;">
      <button id="chatButton" class="nav-button active">💬 Chat</button>
      <button id="explorerButton" class="nav-button secondary">📝 Note Explorer</button>
    </div>
    
    <h3>Gemini API Configuration</h3>
    <label for="geminiApiKey">Gemini API Key:</label>
    <input type="password" id="geminiApiKey" placeholder="Enter your Gemini API key">
    <button id="saveApiKey">Save API Key</button>
    <button id="useDefaultKey" class="secondary">Use Default Key</button>
    
    <div style="margin-top:20px;">
      <h3>Current Status</h3>
      <div id="apiStatus">Using default API key</div>
    </div>
    
    <div style="margin-top:20px;">
        <h3>Workflow Settings</h3>
        <div style="display:flex; flex-direction:column; gap:8px; margin-bottom:16px;">
          <button id="toggleAutoConfirmBtn" class="nav-button" style="background:#2d5a87; color:white; border:none; padding:8px 12px; border-radius:4px; font-size:14px;">
            Auto Confirm: OFF
          </button>
          <small style="color:#666; font-size:12px;">Toggle auto confirmation for all actions</small>
        </div>
      <div style="font-size:12px; color:#a0a0a0; margin-bottom:16px;">
        When enabled, the system will automatically proceed with "Yes" for all confirmation prompts (note creation, deletion, marking as done, etc.)
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Chat History</h3>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <button id="clearChatHistory" class="secondary" style="background:#ff6b35;">🗑️ Clear Chat History</button>
        <small style="color:#a0a0a0; font-size:12px;">Clear all chat messages and history</small>
      </div>
    </div>
    
    <div style="margin-top:20px;">
      <h3>Debug Tools</h3>
      <div style="display:flex; flex-direction:column; gap:8px;">
        <button id="showNotes">Show Notes (Debug)</button>
        <button id="clearNotes" class="secondary" style="background:#ff4444;">🗑️ Clear All Notes (DANGER)</button>
      </div>
      <div id="notesDisplay" style="margin-top:10px; padding:10px; background:#2a2f36; border-radius:6px; max-height:200px; overflow-y:auto; font-family:monospace; font-size:12px; white-space:pre-wrap; display:none;"></div>
    </div>
  </div>
</div>

<script>
/* ---------- Settings ---------- */
const Settings = { 
  lang: "en",
  geminiApiKey: "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4", // Default API key
  autoConfirm: false
};

// Global auto confirmation state
var GlobalAutoConfirm = {
  enabled: false,
  toggle: function() {
    this.enabled = !this.enabled;
    this.updateUI();
    this.saveToStorage();
    this.updateBackend();
    return this.enabled;
  },
  updateUI: function() {
    const btn = document.getElementById('toggleAutoConfirmBtn');
    if (btn) {
      btn.textContent = `Auto Confirm: ${this.enabled ? 'ON' : 'OFF'}`;
      btn.style.background = this.enabled ? '#28a745' : '#2d5a87';
    }
  },
  saveToStorage: function() {
    localStorage.setItem('globalAutoConfirm', this.enabled.toString());
  },
  loadFromStorage: function() {
    const saved = localStorage.getItem('globalAutoConfirm');
    this.enabled = saved === 'true';
    this.updateUI();
  },
  updateBackend: function() {
    // Send current state to backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'set_auto_confirm',
        enabled: this.enabled
      }));
    }
  }
};

/* ---------- UI wiring ---------- */
const logEl   = document.getElementById("log");
const inputEl = document.getElementById("input");
const formEl  = document.getElementById("chat");
const langSel = document.getElementById("lang");
const clearBtn= document.getElementById("clear");
const micBtn  = document.getElementById("micBtn");
const useTTS  = document.getElementById("useTTS");

// Side menu elements
const menuBtn = document.getElementById("menuBtn");
const sideMenu = document.getElementById("sideMenu");
const overlay = document.getElementById("overlay");
const closeMenu = document.getElementById("closeMenu");
const geminiApiKey = document.getElementById("geminiApiKey");
const saveApiKey = document.getElementById("saveApiKey");
const useDefaultKey = document.getElementById("useDefaultKey");
const apiStatus = document.getElementById("apiStatus");
const showNotes = document.getElementById("showNotes");
const notesDisplay = document.getElementById("notesDisplay");
const clearNotes = document.getElementById("clearNotes");
const clearChatHistoryBtn = document.getElementById("clearChatHistory");
// Old checkbox removed - using toggle button system now
const chatButton = document.getElementById("chatButton");
const explorerButton = document.getElementById("explorerButton");

// Commands popup elements
const helpBtn = document.getElementById("helpBtn");
const commandsPopup = document.getElementById("commandsPopup");
const commandsOverlay = document.getElementById("commandsOverlay");
const closeCommands = document.getElementById("closeCommands");
const commandsContent = document.getElementById("commandsContent");

// Backend now handles all context detection

// Dynamic commands cache
let availableCommands = [];
let commandsLoaded = false;

// Command history management
let commandHistory = [];
const MAX_COMMAND_HISTORY = 10;

// Function to add command to history
function addToCommandHistory(command) {
  // Remove if already exists to avoid duplicates
  commandHistory = commandHistory.filter(cmd => cmd !== command);
  // Add to beginning
  commandHistory.unshift(command);
  // Keep only the latest 10
  if (commandHistory.length > MAX_COMMAND_HISTORY) {
    commandHistory = commandHistory.slice(0, MAX_COMMAND_HISTORY);
  }
  // Save to localStorage
  localStorage.setItem('commandHistory', JSON.stringify(commandHistory));
}

// Function to load command history from localStorage
function loadCommandHistory() {
  const saved = localStorage.getItem('commandHistory');
  if (saved) {
    try {
      commandHistory = JSON.parse(saved);
    } catch (e) {
      commandHistory = [];
    }
  }
}

// Function to get command history
function getCommandHistory() {
  return commandHistory;
}

// Function to load available commands from backend
function loadAvailableCommands() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
      ws.send(JSON.stringify({type: 'get_commands'}));
    } catch (error) {
      console.log("Error requesting commands:", error);
    }
  }
}

// Function to generate dynamic commands HTML
function generateDynamicCommands() {
  if (availableCommands.length === 0) {
    return '<div class="command-category"><h4>❌ No commands available</h4></div>';
  }
  
  // Group commands by category
  const categories = {};
  availableCommands.forEach(cmd => {
    if (!categories[cmd.category]) {
      categories[cmd.category] = [];
    }
    categories[cmd.category].push(cmd);
  });
  
  let html = '';
  for (const category in categories) {
    html += `<div class="command-category">`;
    html += `<h4>${category}</h4>`;
    categories[category].forEach(cmd => {
      const commandText = cmd.requiresParam ? cmd.command + ' ' : cmd.command;
      let buttonText = cmd.command;
      
      // Generate command button
      
      // Add description to the button text
      if (cmd.description) {
        buttonText += ` <span style="opacity: 0.6; font-size: 0.85em; font-style: italic;">[${cmd.description}]</span>`;
      }
      
      // Add examples for commands that need parameters
      if (cmd.requiresParam && cmd.examples && cmd.examples.length > 0) {
        const example = cmd.examples[0];
        buttonText += ` <span style="opacity: 0.7; font-size: 0.9em;">(${example})</span>`;
      }
      
      const buttonHtml = `<button class="command-btn" data-command="${commandText}">${buttonText}</button>`;
      html += buttonHtml;
    });
    html += `</div>`;
  }
  
  return html;
}

// Function to update mode based on backend messages (simplified - backend handles context)
function updateModeFromMessage(message) {
  // Backend now handles all context detection, so we just need to trigger command refresh
  if (message.includes("What would you like to do?") || message.includes("מה תרצה לעשות?") ||
      message.includes("To start editing") || message.includes("כדי להתחיל לערוך") ||
      message.includes("Started AI conversation") || message.includes("התחלתי שיחה עם AI") ||
      message.includes("AI conversation cancelled") || message.includes("שיחה עם AI בוטלה") ||
      message.includes("Do you want to create") || message.includes("האם תרצה ליצור") || 
      message.includes("Do you want to delete") || message.includes("האם תרצה למחוק") ||
      message.includes("Do you want to mark") || message.includes("האם תרצה לסמן") ||
      message.includes("Which note would you like to select") || message.includes("איזה פתק תרצה לבחור") ||
      message.includes("updated successfully") || message.includes("עודכן בהצלחה") ||
      message.includes("created successfully") || message.includes("נוצר בהצלחה") ||
      message.includes("deleted successfully") || message.includes("נמחק בהצלחה") ||
      message.includes("cancelled") || message.includes("בוטל")) {
    
    // Request updated commands from backend
    loadAvailableCommands();
  }
}

langSel.onchange = () => {
  Settings.lang = langSel.value;
  document.documentElement.dir = (Settings.lang === "he") ? "rtl" : "ltr";
};
clearBtn.onclick = () => { 
  logEl.innerHTML = ""; 
  clearChatHistory();
};

/* ---------- Commands Popup Functionality ---------- */
// Function to populate commands based on backend context
function populateCommands() {
  commandsContent.innerHTML = '';
  
  // Add history section if there are commands in history
  const history = getCommandHistory();
  if (history.length > 0) {
    let historyHtml = `
      <div class="command-category">
        <h4>🕒 Recent Commands</h4>
    `;
    for (let i = 0; i < Math.min(history.length, 5); i++) {
      const cmd = history[i];
      historyHtml += `<button class="command-btn" data-command="${cmd}">${cmd}</button>`;
    }
    historyHtml += `</div>`;
    commandsContent.innerHTML += historyHtml;
  }
  
  // Use backend commands exclusively
  if (commandsLoaded && availableCommands.length > 0) {
    const generatedHtml = generateDynamicCommands();
    commandsContent.innerHTML += generatedHtml;
  } else {
    // Fallback message if no commands available
    commandsContent.innerHTML += `
      <div class="command-category">
        <h4>❌ No commands available</h4>
        <p>Loading commands from backend...</p>
      </div>
    `;
  }
}

helpBtn.onclick = () => {
  populateCommands();
  commandsPopup.classList.add("show");
  commandsOverlay.classList.add("show");
};

closeCommands.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};

commandsOverlay.onclick = () => {
  commandsPopup.classList.remove("show");
  commandsOverlay.classList.remove("show");
};

// Handle command button clicks
document.addEventListener('click', (e) => {
  console.log("Click detected on:", e.target.tagName, "classes:", e.target.className);
  
  // Find the closest command button (handles clicks on child elements)
  const commandButton = e.target.closest('.command-btn');
  console.log("Closest command button:", commandButton);
  
  if (commandButton) {
    const command = commandButton.getAttribute('data-command');
    console.log("Command button clicked:", command);
    
    if (command) {
      // Add the command to the input field
      inputEl.value = command;
      console.log("Set input value to:", inputEl.value);
      // Add to command history
      addToCommandHistory(command);
      // Close the popup
      commandsPopup.classList.remove("show");
      commandsOverlay.classList.remove("show");
      // Focus on the input field
      inputEl.focus();
    } else {
      console.log("No command attribute found");
    }
  } else {
    // Check if it's a navigation button (don't log as error)
    const navButton = e.target.closest('.nav-button');
    if (!navButton) {
      console.log("Not a command button");
    }
  }
});

/* ---------- Side Menu Functionality ---------- */
menuBtn.onclick = () => {
  sideMenu.classList.add("open");
  overlay.classList.add("show");
  loadStoredApiKey();
};

closeMenu.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

overlay.onclick = () => {
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
};

// Navigation functionality
function navigateToPage(page) {
  // Close the side menu
  sideMenu.classList.remove("open");
  overlay.classList.remove("show");
  
  // Update active button
  document.querySelectorAll('.nav-button').forEach(btn => btn.classList.remove('active'));
  
  switch(page) {
    case 'chat':
      // We're already on the chat page
      chatButton.classList.add('active');
      console.log("Already on Chat page");
      break;
    case 'explorer':
      // Navigate to explorer.html
      window.location.href = 'explorer.html';
      break;
  }
}

// Navigation button handlers
  chatButton.onclick = () => navigateToPage('chat');
  explorerButton.onclick = () => navigateToPage('explorer');
  
  // Auto confirm toggle button
  const toggleAutoConfirmBtn = document.getElementById('toggleAutoConfirmBtn');
  if (toggleAutoConfirmBtn) {
    toggleAutoConfirmBtn.onclick = () => {
      const newState = GlobalAutoConfirm.toggle();
      console.log('Auto confirmation toggled to:', newState);
    };
  }

// Old checkbox handler removed - using toggle button system now

// Load stored API key from localStorage
function loadStoredApiKey() {
  const storedKey = localStorage.getItem('geminiApiKey');
  if (storedKey) {
    geminiApiKey.value = storedKey;
    Settings.geminiApiKey = storedKey;
    apiStatus.textContent = "Using custom API key";
    apiStatus.style.color = "#4CAF50";
  } else {
    apiStatus.textContent = "Using default API key";
    apiStatus.style.color = "#FFA500";
  }
  
  // Old auto confirmation loading removed - using GlobalAutoConfirm system now
  
  // Initialize global auto confirm
  GlobalAutoConfirm.loadFromStorage();
}

// Old auto confirmation functions removed - using GlobalAutoConfirm system now

// Save API key
saveApiKey.onclick = () => {
  const key = geminiApiKey.value.trim();
  if (key) {
    localStorage.setItem('geminiApiKey', key);
    Settings.geminiApiKey = key;
    apiStatus.textContent = "Using custom API key";
    apiStatus.style.color = "#4CAF50";
    addMsg("✅ API key saved successfully!", "sys");
    
    // Send API key to backend for daily summary
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({
          type: 'save_settings',
          geminiApiKey: key
        }));
      } catch (error) {
        console.log("Error sending API key to backend:", error);
      }
    }
  } else {
    addMsg("❌ Please enter a valid API key", "sys");
  }
};

// Use default API key
useDefaultKey.onclick = () => {
  localStorage.removeItem('geminiApiKey');
  Settings.geminiApiKey = "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4";
  geminiApiKey.value = "";
  apiStatus.textContent = "Using default API key";
  apiStatus.style.color = "#FFA500";
  addMsg("✅ Switched to default API key", "sys");
  
  // Send default API key to backend for daily summary
  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
      ws.send(JSON.stringify({
        type: 'save_settings',
        geminiApiKey: "AIzaSyC9dXJT4ol3i2VoK6aqLjX5S7IMKSjwNC4"
      }));
    } catch (error) {
      console.log("Error sending default API key to backend:", error);
    }
  }
};

// Show notes debug
showNotes.onclick = () => {
  if (notesDisplay.style.display === "none") {
    // Request notes from backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      try {
        ws.send(JSON.stringify({type:'debug', action:'get_notes'}));
        showNotes.textContent = "Hide Notes";
        notesDisplay.style.display = "block";
      } catch (error) {
        addMsg("Error sending debug request: " + error.message, "sys");
      }
    } else {
      addMsg("Not connected to backend", "sys");
    }
  } else {
    // Hide notes
    showNotes.textContent = "Show Notes (Debug)";
    notesDisplay.style.display = "none";
  }
};

// Clear all notes
clearNotes.onclick = () => {
  const warningMessage = `⚠️ DANGER: Clear All Notes

This action will PERMANENTLY DELETE:
• All notes and their descriptions
• All sub-notes and their relationships  
• All note history and metadata
• All AI conversation history

🚨 THIS ACTION CANNOT BE UNDONE! 🚨

Are you absolutely sure you want to continue?`;

  if (confirm(warningMessage)) {
    // Double confirmation for extra safety
    const finalConfirm = confirm("FINAL WARNING: This will delete EVERYTHING!\n\nType 'DELETE' in the next prompt to confirm:");
    
    if (finalConfirm) {
      const userInput = prompt("Type 'DELETE' to permanently clear all notes:");
      
      if (userInput === 'DELETE') {
        if (ws && ws.readyState === WebSocket.OPEN) {
          try {
            ws.send(JSON.stringify({type:'debug', action:'clear_notes'}));
            addMsg("🗑️ Clearing all notes... This action cannot be undone!", "sys");
          } catch (error) {
            addMsg("Error sending clear request: " + error.message, "sys");
          }
        } else {
          addMsg("Not connected to backend", "sys");
        }
      } else {
        addMsg("❌ Clear operation cancelled - you must type 'DELETE' exactly", "sys");
      }
    } else {
      addMsg("❌ Clear operation cancelled", "sys");
    }
  } else {
    addMsg("❌ Clear operation cancelled", "sys");
  }
};

// Clear chat history
clearChatHistoryBtn.onclick = () => {
  if (confirm("Are you sure you want to clear all chat history? This action cannot be undone.")) {
    clearChatHistory();
    addMsg("🗑️ Chat history cleared", "sys");
  }
};

/* ---------- WebSocket connection to DroidScript backend ---------- */
let ws;
function connect(){
  // Connect to DroidScript WebSocket server on localhost:8080
  const url = 'ws://localhost:8080';
  ws = new WebSocket(url);
  ws.onopen = ()=>{
    addMsg('Connected to DroidScript backend','sys');
    // Load available commands from backend
    loadAvailableCommands();
    
    // Check for URL parameters to auto-execute commands
    handleUrlParameters();
  };
  ws.onclose= ()=>addMsg('Disconnected from backend','sys');
  ws.onerror= e=>addMsg('WebSocket error','sys');
  ws.onmessage = ev=>{
    try{ 
      const msg=JSON.parse(ev.data); 
      if(msg.type==='reply') {
        // All upload handling is now done natively in DroidScript
        // No need for HTML upload modal
        addMsg(msg.text,'bot');
        
        // Update mode based on backend message
        updateModeFromMessage(msg.text);
        
        // Simple message handling (no more graph popups)
        
      }
      else if(msg.type==='debug_notes') {
        notesDisplay.textContent = msg.notes;
        notesDisplay.style.display = "block";
      }
      else if(msg.type==='debug_cleared') {
        addMsg("All notes cleared successfully!", "sys");
        // Hide notes display if it's showing
        notesDisplay.style.display = "none";
        showNotes.textContent = "Show Notes (Debug)";
      }
      else if(msg.type==='file_selected') {
        console.log("DEBUG: File selected from native picker:", msg.imagePath);
        // Handle the selected file from native picker
        handleNativeFileSelection(msg.imagePath, msg.noteId);
      }
      else if(msg.type==='show_html_file_picker') {
        console.log("DEBUG: Showing HTML file picker for note:", msg.noteId);
        // Show the upload modal directly in the same page
        showUploadModal(msg.noteId);
        addMsg("📷 Select images using the file picker below", "sys");
      }
      else if(msg.type==='available_commands') {
        // Handle dynamic commands from backend
        availableCommands = msg.commands || [];
        commandsLoaded = true;
        console.log("Loaded dynamic commands:", availableCommands);
        // Commands loaded
        // Commands loaded successfully
      }
      else addMsg(ev.data,'sys'); 
    }
    catch{ addMsg(ev.data,'bot'); }
  };
}


/* ---------- Chat flow ---------- */
formEl.addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = (inputEl.value || "").trim();
  if (!text) return;

  addMsg(text, "you");
  
  // Add to command history if it looks like a command
  if (isCommand(text)) {
    addToCommandHistory(text);
  }
  
  // Always send to backend - let backend handle story editing mode
  inputEl.value = "";
  
  // Send to DroidScript backend via WebSocket for intent processing
  if (ws && ws.readyState === WebSocket.OPEN) {
    try {
    const message = {type:'chat', text, lang: Settings.lang, autoConfirm: GlobalAutoConfirm.enabled };
    ws.send(JSON.stringify(message));
    } catch (error) {
      addMsg("Error sending message: " + error.message, "sys");
    }
  } else {
    addMsg("Not connected to backend. Trying to reconnect...", "sys");
    connect();
  }
  scrollToBottom();
});

// Function to check if text looks like a command
function isCommand(text) {
  const commandPatterns = [
    /^\/\w+/i, // Slash commands
    /^(create|find|show|help|edit|delete|mark|talk|stop|yes|no)\b/i,
    /^(צור|מצא|הצג|עזרה|ערוך|מחק|סמן|דבר|עצור|כן|לא)\b/i
  ];
  return commandPatterns.some(pattern => pattern.test(text));
}

/* ---------- Speech-to-Text (Web Speech API) ---------- */
let rec = null;
let isRecording = false;

micBtn.onclick = () => {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
};

function startRecording() {
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SR) { 
    addMsg("❌ Speech Recognition not supported in this browser.", "sys"); 
    return; 
  }
  
  try {
    if (!rec) {
      rec = new SR();
      rec.continuous = true;
      rec.interimResults = true;
      rec.maxAlternatives = 1;
      
      rec.onstart = () => {
        isRecording = true;
        micBtn.textContent = "■ Stop Recording";
        micBtn.classList.add("recording");
        addMsg("🎤 Listening... Speak now", "sys");
      };
      
      rec.onresult = (e) => {
        let finalTranscript = "";
        let interimTranscript = "";
        
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const transcript = e.results[i][0].transcript;
          if (e.results[i].isFinal) {
            finalTranscript += transcript;
          } else {
            interimTranscript += transcript;
          }
        }
        
        // Normal mode - replace content
        if (finalTranscript) {
          inputEl.value = finalTranscript;
        } else if (interimTranscript) {
          inputEl.value = interimTranscript;
        }
      };
      
      rec.onerror = (e) => {
        addMsg("❌ Speech recognition error: " + e.error, "sys");
        stopRecording();
      };
      
      rec.onend = () => {
        stopRecording();
      };
    }
    
    // Set language
    rec.lang = (Settings.lang === "he") ? "he-IL" : "en-US";
    
    // Clear input field
    inputEl.value = "";
    
    // Start recognition
    rec.start();
    
  } catch (error) {
    addMsg("❌ Failed to start speech recognition: " + error.message, "sys");
  }
}

function stopRecording() {
  if (rec && isRecording) {
    rec.stop();
  }
  isRecording = false;
  micBtn.textContent = "🎤 Speak";
  micBtn.classList.remove("recording");
  
  if (inputEl.value.trim()) {
    addMsg("✅ Ready to send: " + inputEl.value, "sys");
  }
}


/* ---------- Text-to-Speech ---------- */
async function speakText(text) {
  if (!useTTS.checked) return;
  
  const lang = (Settings.lang === "he") ? "he" : "en";
  const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=${lang}&client=tw-ob&q=${encodeURIComponent(text)}`;
  
  try {
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      }
    });
    
    if (response.ok) {
      const audioBlob = await response.blob();
      const audioUrl = URL.createObjectURL(audioBlob);
      const audio = new Audio(audioUrl);
      audio.play();
      audio.onended = () => URL.revokeObjectURL(audioUrl);
    } else {
      addMsg("❌ Cannot read message: No internet connection", "sys");
    }
  } catch (error) {
    addMsg("❌ Cannot read message: No internet connection", "sys");
  }
}

/* ---------- URL Parameter Handling ---------- */
function handleUrlParameters() {
  const urlParams = new URLSearchParams(window.location.search);
  const findbyid = urlParams.get('findbyid');
  
  if (findbyid) {
    // Auto-execute /findbyid command
    console.log('Auto-executing /findbyid command for note:', findbyid);
    addMsg(`Auto-finding note ID: ${findbyid}`, 'sys');
    
    // Send the command to the backend
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'chat',
        text: `/findbyid ${findbyid}`,
        lang: Settings.lang,
        autoConfirm: Settings.autoConfirm
      }));
    } else {
      // If WebSocket is not ready, wait a bit and try again
      setTimeout(() => {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'chat',
            text: `/findbyid ${findbyid}`,
            lang: Settings.lang,
            autoConfirm: Settings.autoConfirm
          }));
        }
      }, 1000);
    }
  }
}

/* ---------- Utilities ---------- */
function addMsg(text, who) {
  const div = document.createElement("div");
  div.className = "msg " + (who === "you" ? "you" : who === "bot" ? "bot" : "sys");
  
  // Create message content with timestamp
  const messageContent = document.createElement("div");
  messageContent.className = "msg-content";
  messageContent.textContent = text;
  
  // Create timestamp
  const timestamp = document.createElement("div");
  timestamp.className = "msg-timestamp";
  timestamp.textContent = formatTimestamp(new Date());
  
  // Add content and timestamp to message
  div.appendChild(messageContent);
  div.appendChild(timestamp);
  
  logEl.appendChild(div);
  
  // Save message to chat history
  saveMessageToHistory(text, who);
  
  // Speak bot responses if TTS is enabled
  if (who === "bot" && useTTS.checked) {
    speakText(text);
  }
  
  scrollToBottom();
}
function scrollToBottom(){ logEl.scrollTop = logEl.scrollHeight; }

// Format timestamp for display (like WhatsApp)
function formatTimestamp(date) {
  const now = new Date();
  const messageDate = new Date(date);
  
  // Check if it's today
  if (messageDate.toDateString() === now.toDateString()) {
    return messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Check if it's yesterday
  const yesterday = new Date(now);
  yesterday.setDate(yesterday.getDate() - 1);
  if (messageDate.toDateString() === yesterday.toDateString()) {
    return "Yesterday " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Check if it's this week
  const weekAgo = new Date(now);
  weekAgo.setDate(weekAgo.getDate() - 7);
  if (messageDate > weekAgo) {
    return messageDate.toLocaleDateString([], { weekday: 'short' }) + " " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  
  // Older messages show date and time
  return messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + " " + messageDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

// -------- Chat History Management --------
function saveMessageToHistory(text, who) {
  const message = {
    text: text,
    who: who,
    timestamp: new Date().toISOString()
  };
  
  // Get existing chat history
  let chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  
  // Add new message
  chatHistory.push(message);
  
  // Keep only last 100 messages to prevent localStorage from getting too large
  if (chatHistory.length > 100) {
    chatHistory = chatHistory.slice(-100);
  }
  
  // Save to localStorage
  localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
}

function loadChatHistory() {
  const chatHistory = JSON.parse(localStorage.getItem('chatHistory') || '[]');
  
  // Clear current chat log
  logEl.innerHTML = '';
  
  // Restore all messages with timestamps
  chatHistory.forEach(message => {
    const div = document.createElement("div");
    div.className = "msg " + (message.who === "you" ? "you" : message.who === "bot" ? "bot" : "sys");
    
    // Create message content
    const messageContent = document.createElement("div");
    messageContent.className = "msg-content";
    messageContent.textContent = message.text;
    
    // Create timestamp from stored timestamp
    const timestamp = document.createElement("div");
    timestamp.className = "msg-timestamp";
    timestamp.textContent = formatTimestamp(new Date(message.timestamp));
    
    // Add content and timestamp to message
    div.appendChild(messageContent);
    div.appendChild(timestamp);
    
    logEl.appendChild(div);
  });
  
  // Scroll to bottom
  scrollToBottom();
}

function clearChatHistory() {
  localStorage.removeItem('chatHistory');
  logEl.innerHTML = '';
}

// Initialize settings on page load
function initializeSettings() {
  // Load stored API key
  const storedKey = localStorage.getItem('geminiApiKey');
  if (storedKey) {
    Settings.geminiApiKey = storedKey;
  }
  
  // Load chat history
  loadChatHistory();
}

// Hide tip section after 10 seconds
function hideTipAfterDelay() {
  const tipSection = document.getElementById('tipSection');
  if (tipSection) {
    setTimeout(() => {
      tipSection.style.display = 'none';
    }, 10000); // 10 seconds
  }
}

// Connect to DroidScript backend on page load
initializeSettings();
loadCommandHistory();
connect();
hideTipAfterDelay();

/* ---------- Upload Modal Functionality ---------- */
let currentNoteId = null;
let selectedFiles = [];

// DEPRECATED: HTML upload modal no longer used
// All image uploads now handled natively in DroidScript
function showUploadModal(noteId) {
  console.log("DEBUG: HTML upload modal disabled - using native DroidScript file picker");
  addMsg("📁 Image upload is now handled natively by DroidScript", "sys");
  return; // Exit early - don't show HTML modal
  
  // Setup file input handler
  const fileInput = document.getElementById('fileInput');
  fileInput.onchange = handleFileSelect;
  
  // Also add event listener for better compatibility
  fileInput.addEventListener('change', handleFileSelect);
  
  // Setup drag and drop
  const uploadArea = document.querySelector('.upload-area');
  uploadArea.ondragover = (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
  };
  uploadArea.ondragleave = () => {
    uploadArea.classList.remove('dragover');
  };
  uploadArea.ondrop = (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    handleFileSelect({ target: { files: e.dataTransfer.files } });
  };
}

// Select images function - WebView-compatible approach
function selectImages() {
  console.log("DEBUG: selectImages called");
  console.log("DEBUG: Current selectedFiles length:", selectedFiles.length);
  console.log("DEBUG: User agent:", navigator.userAgent);
  
  // Check if we're in a WebView environment
  const isWebView = navigator.userAgent.includes('wv') || window.AndroidInterface;
  console.log("DEBUG: Detected WebView environment:", isWebView);
  
  // Try to trigger the hidden file input directly
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    console.log("DEBUG: Found file input, triggering HTML file picker");
    console.log("DEBUG: File input current value:", fileInput.value);
    
    // Clear any previous selection
    fileInput.value = '';
    console.log("DEBUG: Cleared file input value");
    
    // Multiple event listeners for WebView compatibility
    const handleFileChange = function(event) {
      console.log("DEBUG: File input change event triggered in selectImages");
      console.log("DEBUG: Event files length:", event.target.files ? event.target.files.length : 'no files');
      if (event.target.files && event.target.files.length > 0) {
        handleFileSelect(event);
      }
      // Remove the event listener after use
      fileInput.removeEventListener('change', handleFileChange);
      fileInput.removeEventListener('input', handleFileChange);
    };
    
    // Add multiple event listeners for better WebView compatibility
    fileInput.addEventListener('change', handleFileChange);
    fileInput.addEventListener('input', handleFileChange);  // Alternative event for WebView
    
    // Also try focus/blur events as some WebViews use these
    const handleFocusEvents = function() {
      console.log("DEBUG: File input focus/blur event - checking for files");
      setTimeout(() => {
        if (fileInput.files && fileInput.files.length > 0) {
          console.log("DEBUG: Files detected via focus/blur check");
          handleFileSelect({ target: fileInput });
        }
      }, 100);
    };
    
    fileInput.addEventListener('focus', handleFocusEvents);
    fileInput.addEventListener('blur', handleFocusEvents);
    
    console.log("DEBUG: Added multiple event listeners, about to click file input");
    fileInput.click();
    console.log("DEBUG: File input clicked");
    
    // WebView-specific polling mechanism
    let pollCount = 0;
    const maxPolls = 30; // Poll for 3 seconds
    const pollInterval = setInterval(() => {
      pollCount++;
      console.log("DEBUG: Polling for files, attempt:", pollCount);
      
      if (fileInput.files && fileInput.files.length > 0) {
        console.log("DEBUG: Files detected via polling:", fileInput.files.length);
        clearInterval(pollInterval);
        handleFileSelect({ target: fileInput });
        return;
      }
      
      if (pollCount >= maxPolls) {
        console.log("DEBUG: Polling timeout reached, no files detected");
        clearInterval(pollInterval);
        // Clean up event listeners
        fileInput.removeEventListener('change', handleFileChange);
        fileInput.removeEventListener('input', handleFileChange);
        fileInput.removeEventListener('focus', handleFocusEvents);
        fileInput.removeEventListener('blur', handleFocusEvents);
        
        if (selectedFiles.length === 0) {
          console.log("DEBUG: No files selected after polling, showing fallback options");
          showWebViewFilePickerFallback();
        }
      }
    }, 100);
    
  } else {
    console.log("DEBUG: File input not found, using native picker");
    selectImagesNative();
  }
}

// WebView fallback for file selection
function showWebViewFilePickerFallback() {
  console.log("DEBUG: Showing WebView file picker fallback");
  
  // Show the alternative options
  const alternatives = document.getElementById('webviewAlternatives');
  if (alternatives) {
    alternatives.style.display = 'block';
    console.log("DEBUG: Showing WebView alternatives UI");
  }
  
  // Show message to user
  addMsg("📷 File picker may not work properly in this WebView environment.", "sys");
  addMsg("Please try the alternative options shown below the upload area.", "sys");
}

// Show manual file input as alternative
function showManualFileInput() {
  console.log("DEBUG: Showing manual file input alternative");
  
  // Create a new file input that might work better in WebView
  const existingInput = document.getElementById('fileInput');
  if (existingInput) {
    existingInput.remove();
  }
  
  // Create a new visible file input
  const newInput = document.createElement('input');
  newInput.type = 'file';
  newInput.id = 'fileInputAlt';
  newInput.multiple = true;
  newInput.accept = 'image/*';
  newInput.style.cssText = 'margin: 10px; padding: 5px; border: 1px solid #444; background: #1a1d21; color: #e6e6e6; border-radius: 4px;';
  
  // Add event listeners
  newInput.addEventListener('change', function(event) {
    console.log("DEBUG: Alternative file input change event");
    if (event.target.files && event.target.files.length > 0) {
      console.log("DEBUG: Files selected via alternative input:", event.target.files.length);
      handleFileSelect(event);
    }
  });
  
  // Add to upload area
  const uploadArea = document.querySelector('.upload-body');
  if (uploadArea) {
    const label = document.createElement('p');
    label.textContent = 'Alternative file picker:';
    label.style.cssText = 'color: #a0a0a0; margin: 10px 0 5px 0; font-size: 14px;';
    
    uploadArea.appendChild(label);
    uploadArea.appendChild(newInput);
    
    addMsg("📂 Alternative file picker added. Please try selecting files with it.", "sys");
  }
}

// Alternative file selection using DroidScript native methods
function selectImagesNative() {
  console.log("DEBUG: selectImagesNative called");
  
  // Send message to DroidScript to open native file picker
  if (ws && ws.readyState === WebSocket.OPEN) {
    const message = {
      type: 'request_file_picker',
      noteId: currentNoteId
    };
    console.log("DEBUG: Requesting native file picker");
    ws.send(JSON.stringify(message));
  } else {
    console.log("DEBUG: WebSocket not connected, falling back to mock");
    selectImages();
  }
}

// Handle file selection from native picker
function handleNativeFileSelection(imagePath, noteId) {
  console.log("DEBUG: handleNativeFileSelection called with:", imagePath, noteId);
  
  // Create a mock file object from the native selection
  const mockFile = {
    name: imagePath.split('/').pop() || 'selected_image.jpg',
    type: 'image/jpeg',
    size: 1024,
    path: imagePath
  };
  
  // Add to selected files
  selectedFiles = [mockFile];
  console.log("DEBUG: Added native file to selectedFiles:", selectedFiles.length);
  
  // Update preview
  updatePreview();
  
  // Enable upload button
  document.getElementById('uploadBtn').disabled = false;
  
  addMsg("📷 Image selected from gallery", "sys");
}

// Close upload modal
function closeUploadModal() {
  document.getElementById('uploadModal').classList.remove('show');
  currentNoteId = null;
  selectedFiles = [];
}

// Handle file selection
function handleFileSelect(event) {
  console.log("DEBUG: handleFileSelect called");
  console.log("DEBUG: Event:", event);
  console.log("DEBUG: Event target:", event.target);
  console.log("DEBUG: Event target files:", event.target.files);
  console.log("DEBUG: Files length:", event.target.files ? event.target.files.length : 'no files');
  
  if (!event.target.files || event.target.files.length === 0) {
    console.log("DEBUG: No files in event, returning early");
    return;
  }
  
  const files = Array.from(event.target.files);
  console.log("DEBUG: Files array:", files);
  console.log("DEBUG: Files array length:", files.length);
  
  // Filter for images only and limit to 5
  const imageFiles = files.filter(file => {
    console.log("DEBUG: Checking file:", file.name, "type:", file.type);
    return file.type.startsWith('image/');
  });
  console.log("DEBUG: Filtered to", imageFiles.length, "image files");
  
  if (imageFiles.length > 5) {
    addMsg("⚠️ Maximum 5 images allowed", "sys");
    imageFiles.splice(5);
  }
  
  selectedFiles = imageFiles;
  console.log("DEBUG: selectedFiles updated to", selectedFiles.length, "files");
  console.log("DEBUG: selectedFiles content:", selectedFiles);
  
  updatePreview();
  
  const uploadBtn = document.getElementById('uploadBtn');
  if (uploadBtn) {
    uploadBtn.disabled = selectedFiles.length === 0;
    console.log("DEBUG: Upload button disabled:", uploadBtn.disabled);
  }
  
  if (selectedFiles.length > 0) {
    console.log("DEBUG: Adding success message for", selectedFiles.length, "files");
    addMsg(`📷 ${selectedFiles.length} image(s) selected`, "sys");
  } else {
    console.log("DEBUG: No image files selected");
    addMsg("📷 No valid image files selected", "sys");
  }
}

// Update preview container
function updatePreview() {
  const container = document.getElementById('previewContainer');
  const uploadBtn = document.getElementById('uploadBtn');
  
  if (selectedFiles.length === 0) {
    container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No images selected</p>';
    uploadBtn.disabled = true;
    return;
  }
  
  // Simple display: just show count and file names
  const fileCount = selectedFiles.length;
  const fileNames = selectedFiles.map(file => file.name).join(', ');
  
  container.innerHTML = `
    <div style="padding: 20px; text-align: center; background: #f5f5f5; border-radius: 8px; margin: 10px 0;">
      <h3 style="margin: 0 0 10px 0; color: #333;">📸 Selected ${fileCount} picture${fileCount > 1 ? 's' : ''}</h3>
      <p style="color: #666; font-size: 14px; margin: 10px 0; word-break: break-all;">${fileNames}</p>
      <button onclick="clearSelectedFiles()" style="background: #ff4444; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin-top: 10px;">Clear Selection</button>
    </div>
  `;
  
  uploadBtn.disabled = false;
}

// Remove file from selection
function removeFile(index) {
  selectedFiles.splice(index, 1);
  updatePreview();
  document.getElementById('uploadBtn').disabled = selectedFiles.length === 0;
}

// Clear all selected files
function clearSelectedFiles() {
  selectedFiles = [];
  updatePreview();
  addMsg("📷 File selection cleared", "sys");
}

// Create mock file selection for testing/fallback
function createMockFileSelection() {
  console.log("DEBUG: Creating mock file selection");
  
  // Create a more realistic mock file object
  const mockFile = {
    name: 'mock_image_' + Date.now() + '.jpg',
    type: 'image/jpeg',
    size: 1024 * 50, // 50KB
    lastModified: Date.now(),
    lastModifiedDate: new Date(),
    webkitRelativePath: '',
    // Add methods that might be called
    stream: function() { return new ReadableStream(); },
    text: function() { return Promise.resolve('mock file content'); },
    arrayBuffer: function() { return Promise.resolve(new ArrayBuffer(1024)); },
    slice: function(start, end, contentType) { 
      return new Blob(['mock'], { type: contentType || this.type }); 
    },
    // Mark as mock for special handling
    isMockFile: true,
    constructor: { name: 'File' }
  };
  
  console.log("DEBUG: Created mock file:", mockFile.name);
  
  // Simulate file selection
  selectedFiles = [mockFile];
  console.log("DEBUG: Mock file added to selectedFiles");
  
  // Update the preview and enable upload button
  updatePreview();
  
  const uploadBtn = document.getElementById('uploadBtn');
  if (uploadBtn) {
    uploadBtn.disabled = false;
    console.log("DEBUG: Upload button enabled for mock file");
  }
  
  // Show success message
  addMsg("🧪 Mock file selected: " + mockFile.name, "sys");
  addMsg("📷 1 image selected (mock file for testing)", "sys");
}

// Upload images
function uploadImages() {
  console.log("DEBUG: uploadImages called");
  console.log("DEBUG: selectedFiles length:", selectedFiles.length);
  console.log("DEBUG: selectedFiles content:", selectedFiles);
  console.log("DEBUG: currentNoteId:", currentNoteId);
  console.log("DEBUG: WebSocket state:", ws ? ws.readyState : 'no ws');
  
  if (selectedFiles.length === 0) {
    console.log("DEBUG: Upload cancelled - no files selected");
    addMsg("❌ No files selected. Please select images first.", "sys");
    return;
  }
  
  if (!currentNoteId) {
    console.log("DEBUG: Upload cancelled - no note ID");
    addMsg("❌ No note ID found. Please try again.", "sys");
    return;
  }
  
  addMsg(`📤 Uploading ${selectedFiles.length} image(s) to note ${currentNoteId}...`, "sys");
  
  // Convert images to base64 and send via WebSocket
  selectedFiles.forEach((file, index) => {
    console.log("DEBUG: Processing file", index, ":", file.name);
    
    // For native files (from DroidScript picker), use the existing path
    if (file.path) {
      console.log("DEBUG: Processing native file:", file.path);
      // Send the native file path directly
      if (ws && ws.readyState === WebSocket.OPEN) {
        const message = {
          type: 'upload_file',
          noteId: currentNoteId,
          filename: file.name,
          fileData: null, // No base64 data needed for native files
          imagePath: file.path
        };
        console.log("DEBUG: Sending WebSocket message for native file:", file.name);
        ws.send(JSON.stringify(message));
      } else {
        console.log("DEBUG: WebSocket not connected, state:", ws ? ws.readyState : 'no ws');
      }
    }
    // For mock files, create mock base64 data
    else if (file.name && file.name.startsWith('test_image_')) {
      const mockBase64Data = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='; // 1x1 transparent PNG
      const imagePath = `images/note_${currentNoteId}_${Date.now()}_${index}.jpg`;
      
      console.log("DEBUG: Sending WebSocket message for mock file:", file.name);
      // Send via WebSocket to DroidScript app
      if (ws && ws.readyState === WebSocket.OPEN) {
        const message = {
          type: 'upload_file',
          noteId: currentNoteId,
          filename: file.name,
          fileData: mockBase64Data,
          imagePath: imagePath
        };
        console.log("DEBUG: WebSocket message:", JSON.stringify(message).substring(0, 100) + "...");
        ws.send(JSON.stringify(message));
      } else {
        console.log("DEBUG: WebSocket not connected, state:", ws ? ws.readyState : 'no ws');
      }
    } else {
      // For real files, resize and compress before uploading
      console.log("DEBUG: Processing real file with resizing:", file.name);
      resizeAndCompressImage(file, function(resizedBase64) {
        const imagePath = `images/note_${currentNoteId}_${Date.now()}_${index}.jpg`;
        
        console.log("DEBUG: Sending WebSocket message for resized file:", file.name);
        // Send via WebSocket to DroidScript app
        if (ws && ws.readyState === WebSocket.OPEN) {
          const message = {
            type: 'upload_file',
            noteId: currentNoteId,
            filename: file.name,
            fileData: resizedBase64,
            imagePath: imagePath
          };
          console.log("DEBUG: WebSocket message:", JSON.stringify(message).substring(0, 100) + "...");
          ws.send(JSON.stringify(message));
        } else {
          console.log("DEBUG: WebSocket not connected, state:", ws ? ws.readyState : 'no ws');
        }
      });
    }
  });
  
  // Close modal after upload
  setTimeout(() => {
    closeUploadModal();
    addMsg("✅ Images uploaded successfully!", "sys");
  }, 1000);
}

// Image resizing and compression function
function resizeAndCompressImage(file, callback) {
  console.log("DEBUG: Resizing image:", file.name, "Size:", file.size, "bytes");
  
  // Check if this is a mock file
  if (file.name && (file.name.startsWith('debug_image') || file.name.startsWith('test_image'))) {
    console.log("DEBUG: Mock file detected, using mock base64 data");
    // Use a small mock base64 image (1x1 transparent PNG)
    const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    callback(mockBase64);
    return;
  }
  
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  const img = new Image();
  
  img.onload = function() {
    console.log("DEBUG: Original image dimensions:", img.width, "x", img.height);
    
    // Calculate new dimensions (max 800px width, maintain aspect ratio)
    const maxWidth = 800;
    const maxHeight = 600;
    let { width, height } = img;
    
    if (width > maxWidth) {
      height = (height * maxWidth) / width;
      width = maxWidth;
    }
    if (height > maxHeight) {
      width = (width * maxHeight) / height;
      height = maxHeight;
    }
    
    console.log("DEBUG: Resized dimensions:", width, "x", height);
    
    // Set canvas size
    canvas.width = width;
    canvas.height = height;
    
    // Draw resized image
    ctx.drawImage(img, 0, 0, width, height);
    
    // Convert to base64 with compression (0.8 quality)
    const resizedBase64 = canvas.toDataURL('image/jpeg', 0.8).split(',')[1];
    
    console.log("DEBUG: Resized image size:", resizedBase64.length, "characters");
    console.log("DEBUG: Compression ratio:", Math.round((1 - resizedBase64.length / (file.size * 1.33)) * 100) + "%");
    
    callback(resizedBase64);
  };
  
  img.onerror = function() {
    console.log("DEBUG: Error loading image, using original file");
    // Fallback to original file
    const reader = new FileReader();
    reader.onload = function(e) {
      const base64Data = e.target.result.split(',')[1];
      callback(base64Data);
    };
    reader.onerror = function(e) {
      console.log("DEBUG: FileReader error, using mock data");
      // Final fallback to mock data
      const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
      callback(mockBase64);
    };
    reader.readAsDataURL(file);
  };
  
  // Load the image
  const reader = new FileReader();
  reader.onload = function(e) {
    img.src = e.target.result;
  };
  reader.onerror = function(e) {
    console.log("DEBUG: FileReader error loading file, using mock data");
    const mockBase64 = 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg==';
    callback(mockBase64);
  };
  reader.readAsDataURL(file);
}


</script>
</body>
</html>
